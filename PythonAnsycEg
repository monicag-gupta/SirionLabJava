The threading module exposes all the methods of the thread module and provides some additional methods −
threading.activeCount() − Returns the number of thread objects that are active.
threading.currentThread() − Returns the number of thread objects in the caller's thread control.
threading.enumerate() − Returns a list of all thread objects that are currently active.
In addition to the methods, the threading module has the Thread class that implements threading. The methods provided by the Thread class are as follows −
run() − The run() method is the entry point for a thread.
start() − The start() method starts a thread by calling the run method.
join([time]) − The join() waits for threads to terminate.
isAlive() − The isAlive() method checks whether a thread is still executing.
getName() − The getName() method returns the name of a thread.
setName() − The setName() method sets the name of a thread.




import _thread
import time

# Define a function for the thread
def print_time( threadName, delay):
   count = 0
   while count < 5:
      time.sleep(delay)
      count += 1
      print ("%s: %s" % ( threadName, time.ctime(time.time()) ))

# Create two threads as follows
try:
   _thread.start_new_thread( print_time, ("Thread-1", 2, ) )
   _thread.start_new_thread( print_time, ("Thread-2", 4, ) )
except:
   print ("Error: unable to start thread")






# importing the threading module
import threading

def print_cube(num):
	""" function to print cube of given num	"""
	print(f"Cube: {num * num * num}")   # using f-strings post python 3.6

def print_square(num):
	"""function to print square of given num """
	print("Square: {}".format(num * num))   

if __name__ == "__main__":
	# creating thread
	t1 = threading.Thread(target=print_square, args=(10,))
	t2 = threading.Thread(target=print_cube, args=(10,))
	t1.start()  # starting thread 1
	t2.start()  # starting thread 2
	t1.join()   # wait until thread 1 is completely executed
	t2.join()   # wait until thread 2 is completely executed
	print("Done!") # both threads completely executed









import threading; import time
class myThread (threading.Thread):
   def __init__(self, threadID, name, counter):
      threading.Thread.__init__(self)
      self.threadID = threadID; self.name = name; self.counter = counter
   def run(self):
      print ("Starting " + self.name)
      threadLock.acquire() # Get lock to synchronize threads
      print_time(self.name, self.counter, 3)
      threadLock.release() # Free lock to release next thread

def print_time(threadName, delay, counter):
   while counter:
      time.sleep(delay); counter -= 1
      print ("%s: %s" % (threadName, time.ctime(time.time())))
threadLock = threading.Lock()
threads = []
# Create new threads
thread1 = myThread(1, "Thread-1", 1);thread2 = myThread(2, "Thread-2", 2)
thread1.start(); thread2.start()
threads.append(thread1); threads.append(thread2) # Add threads to thread list
for t in threads: # Wait for all threads to complete
   t.join()
print ("Exiting Main Thread")








import threading;
import time
class myThread (threading.Thread):
   def __init__(self, threadID, name, counter):
      threading.Thread.__init__(self)
      self.threadID = threadID; self.name = name; self.counter = counter
   def run(self):
      print ("Starting " + self.name)
      threadLock.acquire() # Get lock to synchronize threads
      print_time(self.name, self.counter, 3)
      threadLock.release() # Free lock to release next thread

def print_time(threadName, delay, counter):
   while counter:
      time.sleep(delay); counter -= 1
      print ("%s: %s" % (threadName, time.ctime(time.time())))
threadLock = threading.Lock()
threads = []
# Create new threads
thread1 = myThread(1, "Thread-1", 1);thread2 = myThread(2, "Thread-2", 2)
thread3 = myThread(3, "Thread-3", 2);thread4 = myThread(4, "Thread-4", 2)
thread1.start(); thread2.start()
thread3.start(); thread4.start()
threads.append(thread1); threads.append(thread2) # Add threads to thread list
threads.append(thread3); threads.append(thread4)
for t in threads: # Wait for all threads to complete
   t.join()
print ("Exiting Main Thread")









Synchronous vs. Asynchronous: Allows running multiple tasks concurrently, improving efficiency and responsiveness.
Synchronous: Tasks are performed one after another. If one task takes a long time (e.g., waiting for a network response), the entire program waits.
Asynchronous: Tasks can be performed concurrently. While one task is waiting (e.g., for a network response), other tasks can continue running.
Coroutines: Special functions that can be paused and resumed, defined with async def.
Special functions defined with async def that can be paused and resumed. They are the building blocks of asynchronous code.
Event Loop: Manages the execution of coroutines and tasks.
The core of an asynchronous program. It runs and manages the execution of coroutines and tasks.
Tasks and Futures: Tasks are wrappers around coroutines, and futures represent results of asynchronous computations.
Tasks: Wrappers around coroutines that can be scheduled to run on the event loop.
Futures: Objects that represent a result that is initially unknown but will be computed asynchronously.








import asyncio

async def say_hello1():
    print("Hello1")
    await asyncio.sleep(1)
    print("World1")

async def say_hello2():
    print("Hello2")
    await asyncio.sleep(1)
    print("World2")

# To run the coroutine
asyncio.run(say_hello1())
asyncio.run(say_hello2())

async def main():
  await asyncio.gather(
        say_hello1(),
        say_hello2()
    )

asyncio.run(main())






import asyncio

async def say(name, msg, delay):
    await asyncio.sleep(delay)
    for i in range(3):
        print(name, ":", msg, str(i), "iteration")

async def main():
    task1 = asyncio.create_task(say("Th1","Hello", 1))
    task2 = asyncio.create_task(say("Th2","World", 2))
    await task1
    await task2

asyncio.run(main())




import asyncio

async def risky_task():
    await asyncio.sleep(1)
    raise ValueError("An error occurred")

async def main():
    try:
        await risky_task()
    except ValueError as e:
        print(f"Caught an error: {e}")

asyncio.run(main())









from http.server import BaseHTTPRequestHandler, HTTPServer

class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(b"Hello, world!")

    def do_POST(self):
        content_length = int(self.headers['Content-Length'])  # Get the size of data
        post_data = self.rfile.read(content_length)  # Get the data
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        response = f"POST request received: {post_data.decode('utf-8')}"
        self.wfile.write(response.encode('utf-8'))

def run(server_class=HTTPServer, handler_class=SimpleHTTPRequestHandler, port=8000):
    server_address = ('', port)
    httpd = server_class(server_address, handler_class)
    print(f"Starting httpd server on port {port}...")
    httpd.serve_forever()

if __name__ == "__main__":
    run()










http://localhost:8000/






Post Request:
Open Postman
Send a post request to: http://localhost:8000/
With body-> raw->json->
{ "name": "Alice", "age": 30 }
Press Send to get the response as:
POST request received: {
"name": "Alice",
"age": 30
}

For Get Request:
Open Browser/Postman :
Type the get request:
http://localhost:8000/
Get the output as:
Hello, world!







BaseHTTPRequestHandler: A base class for request handlers. We subclass this to define our custom behavior for handling HTTP requests.
do_GET: Handles GET requests. It sends a 200 response code, sets the content type to text/html, and writes "Hello, world!" to the response.
do_POST: Handles POST requests. It reads the length of the incoming data, reads the data itself, sends a 200 response code, and writes a response indicating the data received.
HTTPServer: A basic HTTP server class. We instantiate this with the server address and our custom request handler.
serve_forever: Starts the server and runs it indefinitely, handling incoming requests.
Running the Server
Save the script to a file, for example, server.py, and run it from the command line:
python server.py
Alternatively Run the Code in IDLE
This will start the server on port 8000. 
You can access it by navigating to http://localhost:8000 in your web browser. It will respond with "Hello, world!" to GET requests and echo back any data sent in POST requests.
Press Ctrl + C to end the server.







Different programming models:
Synchronous Programming: Tasks are handled one at a time.
Polling: Periodically checking the status of tasks.
Threading: Running tasks in separate threads for concurrent execution.
Asyncio: Using Python's asynchronous features for efficient I/O-bound task management.
Cooperative Concurrency With Non-Blocking Calls: Uses asyncio to simulate non-blocking tasks where employees fetch reports without blocking each other.
Synchronous (Blocking) HTTP Calls: Uses the requests library to make HTTP calls sequentially, blocking each employee until the previous task completes.
Asynchronous (Non-Blocking) HTTP Calls: Uses the aiohttp library to make HTTP calls concurrently, allowing employees to perform other tasks while waiting for HTTP responses.
These paradigms demonstrate how different programming models handle multiple tasks, each with its own advantages and use cases. 
Using the employee analogy can help visualize how these concepts apply to real-world scenarios.





Thought Experiment #1: The Synchronous Employee

import time

def respond_to_emails():
    print("Responding to emails...")
    time.sleep(2)
    print("Finished responding to emails")

def attend_meeting():
    print("Attending meeting...")
    time.sleep(2)
    print("Finished attending meeting")

def write_report():
    print("Writing report...")
    time.sleep(2)
    print("Finished writing report")

def main():
    respond_to_emails()
    attend_meeting()
    write_report()

main()











Thought Experiment #2: The Polling Employee

import time

tasks = ["respond_to_emails", "attend_meeting", "write_report"]
task_status = {task: False for task in tasks}

def respond_to_emails():
    print("Responding to emails...")
    time.sleep(2)
    print("Finished responding to emails")
    task_status["respond_to_emails"] = True

def attend_meeting():
    print("Attending meeting...")
    time.sleep(2)
    print("Finished attending meeting")
    task_status["attend_meeting"] = True

def write_report():
    print("Writing report...")
    time.sleep(2)
    print("Finished writing report")
    task_status["write_report"] = True

def main():
    start_time = time.time()
    while not all(task_status.values()):
        for task in tasks:
            if not task_status[task]:
                globals()[task]()
        print("Polling...")
        time.sleep(0.5)
    print(f"All tasks completed in {time.time() - start_time:.2f} seconds")

main()



