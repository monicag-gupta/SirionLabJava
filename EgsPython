# python3 code to illustrate the difference between
# == and is operator. Here, [] is an empty list
list1 = []; list2 = []; list3=list1
print(id(list1)); print(id(list2)); print(id(list3))
if (list1 == list2):
	print("(list1 == list2) is True")
else:
	print("(list1 == list2) is False")
if (list1 is list2):
	print("(list1 is list2) is True")
else:
	print("(list1 is list2) is False")
if (list1 is list3):
	print("(list1 is list3) is True")
else:
	print("(list1 is list3) is False")
list3 = list3 + list2
if (list1 is list3):
	print("(now list1 is list3) is True")
else:
	print("(now list1 is list3) is False")








# importing "copy" for copy operations
import copy
li1 = [1, 2, [3,5], 4] # initializing list 1
# using deepcopy to deep copy
li2 = copy.deepcopy(li1)
# original elements of list
print ("The original elements before deep copying")
for i in range(0,len(li1)):
	print (li1[i],end=" ")
print("\r")
li2[2][0] = 7  # adding and element to new list
# Change is reflected in l2
print ("The new list of elements after deep copying ")
for i in range(0,len( li1)):
	print (li2[i],end=" ")
print("\r")
# Change is NOT reflected in original list as it is a deep copy
print ("The original elements after deep copying")
for i in range(0,len( li1)):
	print (li1[i],end=" ")








# importing "copy" for copy operations
import copy
# initializing list 1
li1 = [1, 2, [3,5], 4]
# using copy to shallow copy
li2 = copy.copy(li1)
# original elements of list
print ("The original elements before shallow copying")
for i in range(0,len(li1)):
	print (li1[i],end=" ")
print("\r")
# adding and element to new list
li2[2][0] = 7
# checking if change is reflected
print ("The original elements after shallow copying")
for i in range(0,len( li1)):
	print (li1[i],end=" ")







import binascii
x = b"Bytes objects are immutable sequences of single bytes"
print(x)
#return an integer representing the Unicode code point of that character.
x = ord(b'm')
print(x)
#create a bytes object
y = b'Python bytes'
#generates a list of codes from the characters of bytes
z = list(y)
print(z)
b_table = bytes.maketrans(b'abcdef', b'uvwxyz')
str = 'Write a Python function to find product of integer values.'
b_new = str.translate(b_table)
print(b_new)
x=binascii.hexlify("Python".encode("utf8"))
print(x)
y=binascii.unhexlify(x).decode("utf8")
print(y)





b'Bytes objects are immutable sequences of single bytes'
109
[80, 121, 116, 104, 111, 110, 32, 98, 121, 116, 101, 115]
Writy u Python zunwtion to zinx proxuwt oz intygyr vuluys.
b'507974686f6e'
Python








#create a bytearray from a bytes object
x = bytearray(b"Python Bytes")
print(x)  # bytearray(b'Python Bytes')
#create a bytearray from a string defining the standard of coding
x = bytearray("Python Bytes", "utf8")
print(x) # bytearray(b'Python Bytes')
#create a bytearray from a list of integers in the range 0 through 255
x = bytearray([94, 91, 101, 125, 111, 35, 120, 101, 115, 101, 200])
print(x) # bytearray(b'^[e}o#xese\xc8')
#bytearray objects are a mutable counterpart to bytes objects
x = bytearray("Python bytearray", "utf8")
print(x) # bytearray(b'Python bytearray')
#can remove items from the bytes
del x[11:15]
print(x) # bytearray(b'Python bytey')
#can add items from the bytes
x[11:15] = b" object"
print(x) # bytearray(b'Python byte object')
#can use the methods of mutable type iterable objects as the lists
x.append(45)
print(x) # bytearray(b'Python byte object-')







#defining the function    
def change_list(list1):    
    list1.append(20)   
    list1.append(30)    
    print("list inside function = ",list1)    
    
#defining the list    
list1 = [10,30,40,50]    
    
#calling the function     
change_list(list1)  
print("list outside function = ",list1)  

Output:
list inside function =  [10, 30, 40, 50, 20, 30]
list outside function =  [10, 30, 40, 50, 20, 30]






#defining the function    
def change_string (str):    
    str = str + " How r you "  
    print("printing the string inside function :",str)  
    
string1 = "Hi there"    
    
#calling the function    
change_string(string1)    
    
print("printing the string outside function :",string1)    

Output:
printing the string inside function : Hi there How r you 
printing the string outside function : Hi there















#the function table(n) prints the table of n    
def table(n):    
    return lambda a:a*n 

n = int(input("Enter the number:"))    

b = table(n) 
#the entered number is passed into the function table. b will now contain a lambda function

for i in range(1,11):    
    print(n,"X",i,"=",b(i)) 
#the lambda function b is called with the iteration variable i  








fn=lambda x:x*x
def HOfn(f):
    return lambda x:f(x)+f(x)

sqsm=HOfn(fn)
sqsm(2)
8







Go to C:\Users\monica\AppData\Local\Programs\Python\Python312\Scripts

Open cmd/Terminal
Sudo or type:

> pip3 install numpy

A lot of packages will be downloaded.. 








import numpy as np
# 1D Array:
arr = np.array([1, 2, 3, 4, 5])
print("1D Array by np.array([1, 2, 3, 4, 5]) : "); print(arr)
# 2D Array:
arr = np.array([[1, 2, 3], [4, 5, 6]])
print("2D Array by np.array([[1, 2, 3], [4, 5, 6]]) : "); print(arr)
# Zeros and Ones:
zeros = np.zeros((3, 3))
print("Zeros by np.zeros((3, 3)) : "); print(zeros)
ones = np.ones((2, 4))
print("Ones by np.ones((2, 4)) : "); print(ones)
# Empty and Full:
empty = np.empty((2, 2))
print("Empty by np.empty((2, 2)) : "); print(empty)
full = np.full((2, 2), 7)
print("Full by np.full((2, 2), 7) : "); print(full)
# Arange and Linspace:
arr = np.arange(0, 10, 2)  # Array from 0 to 10 with step 2
lin = np.linspace(0, 1, 5)  # 5 evenly spaced numbers from 0 to 1
print("Array from 0 to 10 with step 2 by np.arange(0, 10, 2) : "); print(arr)
print("5 evenly spaced numbers from 0 to 1 by np.linspace(0, 1, 5) : "); print(lin)
# Array Operations: Basic Arithmetic:
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print("Array Addition: np.array([1, 2, 3]) + np.array([4, 5, 6]) : "); print(a + b)  # Addition
print("Array Multiplication: np.array([1, 2, 3]) * np.array([4, 5, 6]) : "); print(a * b)  # Element-wise multiplication
print("Array Division: np.array([1, 2, 3]) / np.array([4, 5, 6]) : "); print(a / b)  # Element-wise division
# Universal Functions (ufuncs):
print("Array Square root : np.sqrt(np.array([1, 2, 3])) : "); print(np.sqrt(a))  # Square root
print("Array Exponential : np.exp(np.array([1, 2, 3])) : "); print(np.exp(a))   # Exponential
print("Array Exponential : np.sin(np.array([1, 2, 3])) : "); print(np.sin(a))   # Sine
# Matrix Multiplication:
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])
print("Array Multiplication : np.dot(np.array([[1, 2], [3, 4]]), np.array([[5, 6], [7, 8]])) : ")
print(np.dot(a, b))  # Matrix multiplication
# Broadcasting:
a = np.array([1, 2, 3])
b = np.array([[4], [5], [6]])
print("Broadcasting Addition: np.array([1, 2, 3]) + np.array([[4], [5], [6]]) : "); print(a + b)  # Broadcasting addition
# Aggregation Functions:
a = np.array([[1, 2, 3], [4, 5, 6]])
print("Sum of all elements of: np.array([[1, 2, 3], [4, 5, 6]]): "); print(np.sum(a))      # Sum of all elements
print("Sum of columns of: np.array([[1, 2, 3], [4, 5, 6]]): "); print(np.sum(a, axis=0))  # Sum along columns
print("Mean of: np.array([[1, 2, 3], [4, 5, 6]]): "); print(np.mean(a))     # Mean
print("Max of: np.array([[1, 2, 3], [4, 5, 6]]): "); print(np.max(a))      # Maximum
print("Min of: np.array([[1, 2, 3], [4, 5, 6]]): "); print(np.min(a))      # Minimum
# Reshaping Arrays:
a = np.array([[1, 2, 3], [4, 5, 6]])
print("Reshape to 3X2: np.array([[1, 2, 3], [4, 5, 6]]).reshape((3, 2)): "); print(a.reshape((3, 2)))  # Reshape to 3x2 array
print("\nnumpy Examples ends")














