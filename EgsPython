# python3 code to illustrate the difference between
# == and is operator. Here, [] is an empty list
list1 = []; list2 = []; list3=list1
print(id(list1)); print(id(list2)); print(id(list3))
if (list1 == list2):
	print("(list1 == list2) is True")
else:
	print("(list1 == list2) is False")
if (list1 is list2):
	print("(list1 is list2) is True")
else:
	print("(list1 is list2) is False")
if (list1 is list3):
	print("(list1 is list3) is True")
else:
	print("(list1 is list3) is False")
list3 = list3 + list2
if (list1 is list3):
	print("(now list1 is list3) is True")
else:
	print("(now list1 is list3) is False")








# importing "copy" for copy operations
import copy
li1 = [1, 2, [3,5], 4] # initializing list 1
# using deepcopy to deep copy
li2 = copy.deepcopy(li1)
# original elements of list
print ("The original elements before deep copying")
for i in range(0,len(li1)):
	print (li1[i],end=" ")
print("\r")
li2[2][0] = 7  # adding and element to new list
# Change is reflected in l2
print ("The new list of elements after deep copying ")
for i in range(0,len( li1)):
	print (li2[i],end=" ")
print("\r")
# Change is NOT reflected in original list as it is a deep copy
print ("The original elements after deep copying")
for i in range(0,len( li1)):
	print (li1[i],end=" ")








# importing "copy" for copy operations
import copy
# initializing list 1
li1 = [1, 2, [3,5], 4]
# using copy to shallow copy
li2 = copy.copy(li1)
# original elements of list
print ("The original elements before shallow copying")
for i in range(0,len(li1)):
	print (li1[i],end=" ")
print("\r")
# adding and element to new list
li2[2][0] = 7
# checking if change is reflected
print ("The original elements after shallow copying")
for i in range(0,len( li1)):
	print (li1[i],end=" ")







import binascii
x = b"Bytes objects are immutable sequences of single bytes"
print(x)
#return an integer representing the Unicode code point of that character.
x = ord(b'm')
print(x)
#create a bytes object
y = b'Python bytes'
#generates a list of codes from the characters of bytes
z = list(y)
print(z)
b_table = bytes.maketrans(b'abcdef', b'uvwxyz')
str = 'Write a Python function to find product of integer values.'
b_new = str.translate(b_table)
print(b_new)
x=binascii.hexlify("Python".encode("utf8"))
print(x)
y=binascii.unhexlify(x).decode("utf8")
print(y)





b'Bytes objects are immutable sequences of single bytes'
109
[80, 121, 116, 104, 111, 110, 32, 98, 121, 116, 101, 115]
Writy u Python zunwtion to zinx proxuwt oz intygyr vuluys.
b'507974686f6e'
Python

