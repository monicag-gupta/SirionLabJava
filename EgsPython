# python3 code to illustrate the difference between
# == and is operator. Here, [] is an empty list
list1 = []; list2 = []; list3=list1
print(id(list1)); print(id(list2)); print(id(list3))
if (list1 == list2):
	print("(list1 == list2) is True")
else:
	print("(list1 == list2) is False")
if (list1 is list2):
	print("(list1 is list2) is True")
else:
	print("(list1 is list2) is False")
if (list1 is list3):
	print("(list1 is list3) is True")
else:
	print("(list1 is list3) is False")
list3 = list3 + list2
if (list1 is list3):
	print("(now list1 is list3) is True")
else:
	print("(now list1 is list3) is False")








# importing "copy" for copy operations
import copy
li1 = [1, 2, [3,5], 4] # initializing list 1
# using deepcopy to deep copy
li2 = copy.deepcopy(li1)
# original elements of list
print ("The original elements before deep copying")
for i in range(0,len(li1)):
	print (li1[i],end=" ")
print("\r")
li2[2][0] = 7  # adding and element to new list
# Change is reflected in l2
print ("The new list of elements after deep copying ")
for i in range(0,len( li1)):
	print (li2[i],end=" ")
print("\r")
# Change is NOT reflected in original list as it is a deep copy
print ("The original elements after deep copying")
for i in range(0,len( li1)):
	print (li1[i],end=" ")








# importing "copy" for copy operations
import copy
# initializing list 1
li1 = [1, 2, [3,5], 4]
# using copy to shallow copy
li2 = copy.copy(li1)
# original elements of list
print ("The original elements before shallow copying")
for i in range(0,len(li1)):
	print (li1[i],end=" ")
print("\r")
# adding and element to new list
li2[2][0] = 7
# checking if change is reflected
print ("The original elements after shallow copying")
for i in range(0,len( li1)):
	print (li1[i],end=" ")







import binascii
x = b"Bytes objects are immutable sequences of single bytes"
print(x)
#return an integer representing the Unicode code point of that character.
x = ord(b'm')
print(x)
#create a bytes object
y = b'Python bytes'
#generates a list of codes from the characters of bytes
z = list(y)
print(z)
b_table = bytes.maketrans(b'abcdef', b'uvwxyz')
str = 'Write a Python function to find product of integer values.'
b_new = str.translate(b_table)
print(b_new)
x=binascii.hexlify("Python".encode("utf8"))
print(x)
y=binascii.unhexlify(x).decode("utf8")
print(y)





b'Bytes objects are immutable sequences of single bytes'
109
[80, 121, 116, 104, 111, 110, 32, 98, 121, 116, 101, 115]
Writy u Python zunwtion to zinx proxuwt oz intygyr vuluys.
b'507974686f6e'
Python








#create a bytearray from a bytes object
x = bytearray(b"Python Bytes")
print(x)  # bytearray(b'Python Bytes')
#create a bytearray from a string defining the standard of coding
x = bytearray("Python Bytes", "utf8")
print(x) # bytearray(b'Python Bytes')
#create a bytearray from a list of integers in the range 0 through 255
x = bytearray([94, 91, 101, 125, 111, 35, 120, 101, 115, 101, 200])
print(x) # bytearray(b'^[e}o#xese\xc8')
#bytearray objects are a mutable counterpart to bytes objects
x = bytearray("Python bytearray", "utf8")
print(x) # bytearray(b'Python bytearray')
#can remove items from the bytes
del x[11:15]
print(x) # bytearray(b'Python bytey')
#can add items from the bytes
x[11:15] = b" object"
print(x) # bytearray(b'Python byte object')
#can use the methods of mutable type iterable objects as the lists
x.append(45)
print(x) # bytearray(b'Python byte object-')







#defining the function    
def change_list(list1):    
    list1.append(20)   
    list1.append(30)    
    print("list inside function = ",list1)    
    
#defining the list    
list1 = [10,30,40,50]    
    
#calling the function     
change_list(list1)  
print("list outside function = ",list1)  

Output:
list inside function =  [10, 30, 40, 50, 20, 30]
list outside function =  [10, 30, 40, 50, 20, 30]






#defining the function    
def change_string (str):    
    str = str + " How r you "  
    print("printing the string inside function :",str)  
    
string1 = "Hi there"    
    
#calling the function    
change_string(string1)    
    
print("printing the string outside function :",string1)    

Output:
printing the string inside function : Hi there How r you 
printing the string outside function : Hi there





























