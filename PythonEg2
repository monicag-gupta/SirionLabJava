EmployeeClass.py


class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print ("Total Employee %d" % Employee.empCount)

   def displayEmployee(self):
      print ("Name : ", self.name,  ", Salary: ", self.salary)

"This would create first object of Employee class"
emp1 = Employee("Jarom", 10000)
"This would create second object of Employee class"
emp2 = Employee("Monica", 5000)
emp1.displayEmployee()
emp2.displayEmployee()
print ("Total Employee %d" % Employee.empCount)






class Student:  
    def __init__(self, name, id, age):  
        self.name = name  
        self.id = id  
        self.age = age  
     
# creates the object of the class Student  
s = Student("John", 101, 22)  

# prints the attribute name of the object s  
print(getattr(s, 'name'))  
  
# reset the value of attribute age to 23  
setattr(s, "age", 23)  
  
# prints the modified value of age  
print(getattr(s, 'age'))  
  
# prints true if the student contains the attribute with name id  
  
print(hasattr(s, 'id'))  
# deletes the attribute age  
delattr(s, 'age')  
  
# this will give an error since the attribute age has been deleted  
# this will give an error since the attribute age has been deleted  
# print(s.age)
print(hasattr(s, 'age'))  













class Student:
    "This is a student class" # This is not a doc comment
    def __init__(self, name, id, age):  
        self.name = name  
        self.id = id  
        self.age = age
    def display(self):
        print("ID : " , self.id, "Name: ", self.name, "Age : ",self.age)
        
     
# creates the object of the class Student  
s = Student("John", 101, 22)
s.display()

# prints the attribute name of the object s  
print(getattr(s, 'name'))  
  
# reset the value of attribute age to 23  
setattr(s, "age", 23)  
  
# prints the modified value of age  
print(getattr(s, 'age'))  
  
# prints true if the student contains the attribute with name id  
  
print(hasattr(s, 'id'))  
# deletes the attribute age  
delattr(s, 'age')  
  
# this will give an error since the attribute age has been deleted  
# print(s.age)
print(hasattr(s, 'age'))
s.display()








from EmployeeClass import Employee

print ("Employee.__doc__:", Employee.__doc__)
# Employee.__doc__: Common base class for all employees

print ("Employee.__name__:", Employee.__name__)
# Employee.__name__: Employee

print ("Employee.__module__:", Employee.__module__)
# Employee.__module__: EmployeeClass

print ("Employee.__bases__:", Employee.__bases__)
# Employee.__bases__: (<class 'object'>,)

print ("Employee.__dict__:", Employee.__dict__)
# Employee.__dict__: {'__module__': 'EmployeeClass', '__doc__': 'Common base class for all employees', 'empCount': 2, '__init__': <function Employee.__init__ at 0x02E3ADF0>, 'displayCount': <function Employee.displayCount at 0x02E3ADA8>, 'displayEmployee': <function Employee.displayEmployee at 0x02E3AD60>, '__dict__': <attribute '__dict__' of 'Employee' objects>, '__weakref__': <attribute '__weakref__' of 'Employee' objects>}






class Point:
   def __init__( self, x=0, y=0):
      self.x = x
      self.y = y
   def __del__(self):
      class_name = self.__class__.__name__
      print (class_name, "destroyed")

pt1 = Point()
pt2=pt1
print ("id(pt1):",id(pt1)) # prints the ids of the objects
print ("id(pt2)", id(pt2)) # prints the ids of the objects
del pt1
print("pt1 destroyed, but pt2 with same id lives")
del pt2






class Animal:  
    def speak(self):  
        print("Animal Speaking")  

#child class Dog inherits the base class Animal  

class Dog(Animal):  
    def bark(self):  
        print("dog barking")  


d = Dog()  
d.bark()  
d.speak()  

Output:
dog barking
Animal Speaking




class Employee:
    def stName(self,name):
        self.name=name
    def disp(self):  
        print("Employee: ", self.name)  

class Sal_Emp(Employee):
    def stNameSal(self, name,sal):
        self.sal=sal
        Employee.stName(Employee,name)
    def prnt(self):  
        print("Salaried Employee: ", self.name, self.sal)  

e=Sal_Emp()
e.stNameSal("Jarom",102)
e.disp() # using disp() from parent class
e.prnt()
print(e.name, e.sal)








class Animal:  
    def speak(self):  
        print("Animal Speaking")  
#The child class Dog inherits the base class Animal  
class Dog(Animal):  
    def bark(self):  
        print("dog barking")  
#The child class Dogchild inherits another child class Dog  
class DogChild(Dog):  
    def eat(self):  
        print("Eating bread...")  

d = DogChild()  
d.bark()  
d.speak()  
d.eat() 

Output:
dog barking
Animal Speaking
Eating bread...






class Calculation1:  
    def Summation(self,a,b):  
        return a+b;  
class Calculation2:  
    def Multiplication(self,a,b):  
        return a*b;  
class Derived(Calculation1,Calculation2):  
    def Divide(self,a,b):  
        return a/b;  

d = Derived()  
print(d.Summation(10,20))  
print(d.Multiplication(10,20))  
print(d.Divide(10,20))  

Output:
30
200
0.5





The issubclass(sub, sup) method is used to check the relationships between the specified classes. It returns true if the first class is the subclass of the second class, and false otherwise. 
Example:

class Calculation1:  
    def Summation(self,a,b):  
        return a+b;  
class Calculation2:  
    def Multiplication(self,a,b):  
        return a*b;  
class Derived(Calculation1,Calculation2):  
    def Divide(self,a,b):  
        return a/b;  

d = Derived()  
print(issubclass(Derived,Calculation2))  
print(issubclass(Calculation1,Calculation2))  

Output:
True
False



The isinstance() method is used to check the relationship between the objects and classes. It returns true if the first parameter, i.e., obj is the instance of the second parameter, i.e., class.

Example:

class Calculation1:  
    def Summation(self,a,b):  
        return a+b;  
class Calculation2:  
    def Multiplication(self,a,b):  
        return a*b;  
class Derived(Calculation1,Calculation2):  
    def Divide(self,a,b):  
        return a/b;  
d = Derived()  
print(isinstance(d,Derived)) 
print(isinstance(d,Calculation1)) 

Output:
True
True



We can provide some specific implementation of the parent class method in our child class. When the parent class method is defined in the child class with some specific implementation, then the concept is called method overriding. We may need to perform method overriding in the scenario where the different definition of a parent class method is needed in the child class.

Example:

class Animal:  
    def speak(self):  
        print("speaking")  
class Dog(Animal):  
    def speak(self):  
        print("Barking")  
d = Dog()  
d.speak()  
d=Animal()
d.speak()

Output:
Barking
speaking






class Bank:  
    def getroi(self):  
        return 10;  
class SBI(Bank):  
    def getroi(self):  
        return 7;  
class ICICI(Bank):  
    def getroi(self):  
        return 8;  

b1 = Bank()  
b2 = SBI()  
b3 = ICICI()  
print("Bank Rate of interest:",b1.getroi());  
print("SBI Rate of interest:",b2.getroi());  
print("ICICI Rate of interest:",b3.getroi());  

Output:
Bank Rate of interest: 10
SBI Rate of interest: 7
ICICI Rate of interest: 8



__init__ ( self [,args...] )
Constructor (with any optional arguments)
Sample Call : obj = className(args)
__del__( self )
Destructor, deletes an object
Sample Call : del obj
__repr__( self )
Evaluable string representation
Sample Call : repr(obj)
__str__( self )
Printable string representation
Sample Call : str(obj)
__cmp__ ( self, x )
Object comparison
Sample Call : cmp(obj, x)





















class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b
   def __str__(self):
      return 'Vector (%d, %d)' % (self.a, self.b)
   
   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)

Output:
Vector(7,8)



public:
   Vector operator +(Vector v2){
      return new Vector(this.a + v2.a, this.b + v2.b);
   }



https://www.programiz.com/python-programming/operator-overloading









Abstraction is an important aspect of object-oriented programming. 
In python, we can also perform data hiding by adding the double underscore (__) as a prefix to the attribute which is to be hidden. 
After this, the attribute will not be visible outside of the class through the object.

Example:
class Employee:  
    __count = 0;  
    def __init__(self):  
        Employee.__count = Employee.__count+1  
    def display(self):  
        print("The number of employees",Employee.__count)  

emp = Employee()  
emp2 = Employee()  
#print(emp.__count)  
emp.display()  

Output:
The number of employees 2
AttributeError: 'Employee' object has no attribute '__count'



Python protects those members by internally changing the name to include the class name. You can access such attributes as object._className__attrName. 
If you would replace your last line as following, then it works for you −

print(emp._Employee__count)
2







The class method in Python is a method, which is bound to the class but not the object of that class. 
The static methods are also same but there are some basic differences. 
For class methods, we need to specify @classmethod decorator, and for static method @staticmethod decorator is used.

Syntax for Class Method.
class my_class:
   @classmethod
  def function_name(cls, arguments):
      #Function Body
      return value

Syntax for Static Method.
class my_class:
   @staticmethod
   def function_name(arguments):
      #Function Body
      return value



from datetime import date as dt
class Employee:
   def __init__(self, name, age):
      self.name = name
      self.age = age
   @staticmethod
   def isAdult(age):
      if age > 18:
         return True
      else:
         return False
   @classmethod
   def emp_from_year(Employee, name, year):
      return Employee(name, dt.today().year - year)
   def __str__(self):
      return 'Employee Name: {} and Age: {}'.format(self.name, self.age)
e1 = Employee('Dhiman', 25)
print(e1)
e2 = Employee.emp_from_year('Subhas', 1987)
print(e2)
print(Employee.isAdult(25))
print(Employee.isAdult(16))







Exception Name 
Description
Exception
Base class for all exceptions
StopIteration
Raised when the next() method of an iterator does not point to any object.
SystemExit
Raised by the sys.exit() function.
StandardError
Base class for all built-in exceptions except StopIteration and SystemExit.
ArithmeticError
Base class for all errors that occur for numeric calculation.
OverflowError
Raised when a calculation exceeds maximum limit for a numeric type.
FloatingPointError
Raised when a floating point calculation fails.
ZeroDivisionError
Raised when division or modulo by zero takes place for all numeric types.
AssertionError
Raised in case of failure of the Assert statement.
AttributeError
Raised in case of failure of attribute reference or assignment.
EOFError
Raised if there is no input from input() function and the end of file is reached.
ImportError
Raised when an import statement fails.
KeyboardInterrupt
Raised when the user interrupts program execution, usually by pressing Ctrl+c.
LookupError
Base class for all lookup errors.
IndexError
Raised when an index is not found in a sequence.
KeyError
Raised when the specified key is not found in the dictionary.
NameError
Raised when an identifier is not found in the local or global namespace.
UnboundLocalError
Raised when trying to access a local unassigned variable in a function or method.
EnvironmentError
Base class for all exceptions that occur outside the Python environment.
IOError
Raised when an input/ output operation fails.
SyntaxError
Raised when there is an error in Python syntax.
IndentationError
Raised when indentation is not specified properly.
SystemError
Raised when the interpreter finds an internal unhandled problem and it does not exit.
SystemExit
Raised when Python interpreter is quit by using the sys.exit() function.
TypeError
Raised when an operation or function is attempted that is invalid for the specified data type.
ValueError
Raised when the invalid arguments is specified for built-in functions..
RuntimeError
Raised when a generated error does not fall into any category.
NotImplementedError
Raised when an abstract method that still needs to be implemented in an inherited class.








The try-expect statement
If the Python program contains suspicious code that may throw the exception, we must place that code in the try block. 
The try block must be followed with the except statement, which contains a block of code that will be executed if there is some exception in the try block.
Syntax
try:
   You do your operations here;
except ExceptionI:
   If there is ExceptionI, then execute this block.
[except ExceptionII:
   If there is ExceptionII, then execute this block……]
else:
   If there is no exception then execute this block. 






try:
    a=10/0
    print (a)
except ArithmeticError:
    print ("This statement is raising an exception")
else:
    print ("Welcome")
  
Output:
>>>   
This statement is raising an exception  
>>>  




try:    
    a = int(input("Enter a:"))    
    b = int(input("Enter b:"))    
    c = a/b  
    print("a/b = %d"%c)    
# Using Exception with except statement. If we print(Exception) it will return exception class  
except Exception:    
    print("can't divide by zero")    
    print(Exception)  
else:    
    print("Hi I am else block") 




Run1:
Enter a:10
Enter b:5
a/b = 2
Hi I am else block

Run2:
Enter a:10
Enter b:0
can't divide by zero
<class 'Exception'>



try:
    a = int(input("Enter a:"))
    b = int(input("Enter b:"))
    c = a/b
    print("a/b = %d"%c)
    # Using exception object with the except statement
except Exception as e:
    print("can't divide by zero")
    print(e)
else:
    print("Hi I am else block")
finally:
    print("Hi I am finally block")











try:    
    age = int(input("Enter the age:"))    
    if(age<18):    
        raise ValueError   
    else:    
        print("the age is valid")    
except ValueError:    
    print("The age is not valid")

Output:    
Enter the age:10
The age is not valid





try:  
    a=10  
    print (a)  
    raise NameError("Hello")  
except NameError as e:  
        print ("An exception occurred")  
        print(e) 

Output:
>>>   
10  
An exception occurred  
Hello  
>>>  






Python also allows you to create your own exceptions by deriving classes from the standard built-in exceptions.

Here is an example related to RuntimeError. Here, a class is created that is subclassed from RuntimeError. 
This is useful when you need to display more specific information when an exception is caught.
In the try block, the user-defined exception is raised and caught in the except block. The variable e is used to create an instance of the class Networkerror.

class Networkerror(RuntimeError):
   def __init__(self, arg):
      self.args = arg
# So once you defined above class, you can raise the exception as follows −
try:
   raise Networkerror("Bad hostname")
except Networkerror as e:
   print(e.args)

# Output:   
# ('B', 'a', 'd', ' ', 'h', 'o', 's', 't', 'n', 'a', 'm', 'e')






def KelvinToFahrenheit(Temperature):
   assert (Temperature >= 0),"Colder than absolute zero!"
   return ((Temperature-273)*1.8)+32

print(KelvinToFahrenheit(273))
# 32.0
print(int(KelvinToFahrenheit(505.78)))
# 451
print(KelvinToFahrenheit(-5))





Traceback (most recent call last):
  File "<pyshell#34>", line 1, in <module>
    print(KelvinToFahrenheit(-5))
  File "<pyshell#31>", line 2, in KelvinToFahrenheit
    assert (Temperature >= 0),"Colder than absolute zero!"
AssertionError: Colder than absolute zero!
>>> 



To work with files, you need to open them using the open() function. This function returns a file object, which provides methods and attributes to interact with the file.
file = open('filename.txt', 'mode')
Modes:
'r': Read (default mode). Opens a file for reading.
'w': Write. Opens a file for writing (creates a new file or truncates an existing file).
'a': Append. Opens a file for appending (creates a new file if it does not exist).
'b': Binary mode. Opens the file in binary mode (e.g., 'rb' or 'wb').
'x': Exclusive creation. Fails if the file already exists.
't': Text mode (default). Opens the file in text mode.






To write data to a file, you can use the write() or writelines() methods.
Example: Writing to a File
# Open a file for writing
with open('example.txt', 'w') as file:
    file.write('Hello, World!\n')
    file.write('This is a test file.\n')
print("Data written to example.txt")







To read data from a file, you can use the read(), readline(), or readlines() methods.
Example: Reading from a File
# Open a file for reading
with open('example.txt', 'r') as file:
    content = file.read()  # Read the entire file
    print("File content:")
    print(content)

# Alternatively, read line by line
with open('example.txt', 'r') as file:
    for line in file:
        print(line.strip())  # Print each line without extra newline characters







To add data to the end of a file without truncating it, you can open the file in append mode.
Example: Appending to a File
# Open a file for appending
with open('example.txt', 'a') as file:
    file.write('This line will be appended to the file.\n')
print("Data appended to example.txt")







To read and write binary files (e.g., images, audio), use the binary mode.
Example: Writing and Reading a Binary File

# Writing a binary file
data = bytes([0, 255, 127, 64])
with open('example.bin', 'wb') as file:
    file.write(data)
print("Binary data written to example.bin")

# Reading a binary file
with open('example.bin', 'rb') as file:
    binary_data = file.read()
    print("Binary data read from example.bin:", binary_data)






When performing file I/O, it’s a good practice to handle exceptions, such as file not found or permission errors.
Example: Handling Exceptions
try:
    with open('nonexistent.txt', 'r') as file:
        content = file.read()
except FileNotFoundError:
    print("The file does not exist.")
except PermissionError:
    print("You do not have permission to access this file.")














import os

def display_menu():
    print("\nMenu:")
    print("1. Write to file")
    print("2. Read from file")
    print("3. Update content of file")
    print("4. Delete content of file")
    print("5. Delete specific employee record")
    print("6. Delete file")
    print("7. Exit")

def write_to_file(filename):
    employee_id = input("Enter Employee ID: ")
    employee_name = input("Enter Employee Name: ")
    with open(filename, 'a') as file:
        file.write(f"{employee_id},{employee_name}\n")
    print("Data written to file.")

def read_from_file(filename):
    if os.path.exists(filename):
        with open(filename, 'r') as file:
            content = file.read()
            print(content if content else "File is empty.")
    else:
        print("File does not exist.")

def update_content_of_file(filename):
    if os.path.exists(filename):
        employee_id = input("Enter Employee ID to update: ")
        found = False
        new_content = []
        with open(filename, 'r') as file:
            lines = file.readlines()
            for line in lines:
                emp_id, emp_name = line.strip().split(',')
                if emp_id == employee_id:
                    new_name = input(f"Enter new name for Employee ID {employee_id}: ")
                    new_content.append(f"{emp_id},{new_name}\n")
                    found = True
                else:
                    new_content.append(line)
        
        if found:
            with open(filename, 'w') as file:
                file.writelines(new_content)
            print("Data updated.")
        else:
            print("Employee ID not found.")
    else:
        print("File does not exist.")

def delete_content_of_file(filename):
    if os.path.exists(filename):
        open(filename, 'w').close()
        print("Content of the file deleted.")
    else:
        print("File does not exist.")

def delete_employee_record(filename):
    if os.path.exists(filename):
        employee_id = input("Enter Employee ID to delete: ")
        found = False
        new_content = []
        with open(filename, 'r') as file:
            lines = file.readlines()
            for line in lines:
                emp_id, emp_name = line.strip().split(',')
                if emp_id != employee_id:
                    new_content.append(line)
                else:
                    found = True
        
        if found:
            with open(filename, 'w') as file:
                file.writelines(new_content)
            print(f"Employee ID {employee_id} deleted.")
        else:
            print("Employee ID not found.")
    else:
        print("File does not exist.")

def delete_file(filename):
    if os.path.exists(filename):
        os.remove(filename)
        print("File deleted.")
    else:
        print("File does not exist.")

def main():
    filename = "employees.txt"
    
    while True:
        display_menu()
        choice = input("Enter your choice: ")
        
        if choice == '1':
            write_to_file(filename)
        elif choice == '2':
            read_from_file(filename)
        elif choice == '3':
            update_content_of_file(filename)
        elif choice == '4':
            delete_content_of_file(filename)
        elif choice == '5':
            delete_employee_record(filename)
        elif choice == '6':
            delete_file(filename)
        elif choice == '7':
            print("Exiting the program.")
            break
        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()







import numpy as np

x = np.linspace(0, 5, 10)
y = np.sin(x)

print(x)
print(y)









https://www.jetbrains.com/pycharm/download/other.html

Download the community edition : pycharm-community-2024.1.4.exe

Download the .exe file
Install pycharm with all defaults



Run in Terminal:
sudo apt update
sudo apt install snapd
sudo snap install pycharm-community --classic  
# For Community Edition
pycharm-community  # Launch Community Edition














