Spring Cloud Config Server
Spring Cloud Config Server provides the HTTP resource-based API for external configuration in the distributed system. We can enable the Spring Cloud Config Server by using the annotation @EnableConfigServer.
Netflix Eureka Naming Server
Netflix Eureka Server is a discovery server. It provides the REST interface to the outside for communicating with it. A microservice after coming up, register itself as a discovery client. The Eureka server also has another software module called Eureka Client. Eureka client interacts with the Eureka server for service discovery. The Eureka client also balances the client requests.
Hystrix Server
Hystrix server acts as a fault-tolerance robust system. It is used to avoid complete failure of an application. It does this by using the Circuit Breaker mechanism. If the application is running without any issue, the circuit remains closed. If there is an error encountered in the application, the Hystrix Server opens the circuit. The Hystrix server stops the further request to calling service. It provides a highly robust system.
Netflix Zuul API Gateway Server
Netflix Zuul Server is a gateway server from where all the client request has passed through. It acts as a unified interface to a client. It also has an inbuilt load balancer to load the balance of all incoming request from the client.
Netflix Ribbon
Netflix Ribbon is the client-side Inter-Process Communication (IPC) library. It provides the client-side balancing algorithm. It uses a Round Robin Load Balancing: Load balancing, Fault tolerance, Multiple protocols(HTTP, TCP, UDP), Caching and Batching
Zipkin Distributed Server
Zipkin is an open-source project m project. That provides a mechanism for sending, receiving, and visualization traces.









Spring Cloud Config Server
8888
Netflix Eureka Naming Server
8761
Netflix Zuul API gateway Server
8765
Zipkin distributed Tracing Server
9411








Spring Boot has become a popular framework for building microservices due to its simplicity and powerful features. When developing microservices with Spring Boot, several design patterns and best practices are commonly employed to ensure scalability, resilience, and maintainability. Here are some key patterns and considerations:
Service Registration and Discovery: Use of a service registry (like Netflix Eureka, Consul, or Spring Cloud Netflix) for service registration and a discovery client to locate services dynamically.
Externalized Configuration: Utilize Spring Boot's externalized configuration capabilities (via application.properties or YAML files) to separate configuration from code, making microservices easier to configure and deploy across different environments.
Centralized Logging: Implement centralized logging using tools like ELK Stack (Elasticsearch, Logstash, Kibana) or Splunk for easier debugging and monitoring of microservices.
Database per Service: Each microservice should ideally have its own database to ensure loose coupling and independence. Use technologies like Spring Data JPA for easy database access and management.
API Gateway: Implement an API Gateway (e.g., Spring Cloud Gateway, Netflix Zuul) to handle routing, load balancing, authentication, and monitoring of requests from clients to microservices.
Circuit Breaker: Implement the Circuit Breaker pattern (e.g., Netflix Hystrix or Resilience4j) to prevent cascading failures and provide fallback options when microservices are unavailable.
Event-driven Architecture: Use asynchronous messaging and event-driven patterns (e.g., Kafka, RabbitMQ, Spring Cloud Stream) to enable communication between microservices while ensuring loose coupling and scalability.
Containerization and Orchestration: Containerize microservices using Docker and orchestrate them with Kubernetes or Docker Swarm for easier deployment, scaling, and management of containers.
Fault Tolerance and Resilience: Design microservices to be resilient to failures by implementing retry mechanisms, timeouts, and fallbacks in critical operations.
Monitoring and Health Checks: Implement health checks and metrics endpoints (e.g., Spring Boot Actuator) to monitor the health and performance of microservices in real-time.
These patterns help address common challenges in building and deploying microservices, ensuring they are scalable, resilient, and easy to manage in a distributed environment.




SB Project:
limits-service

Group: com.example
Package:
com.example.demo


Add Dependencies:
Spring Web, Spring Boot DevTools, Spring Boot Actuator, Config Client




<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring-cloud-starter-bootstrap</artifactId>
</dependency>





package com.limitsService;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import com.limitsService.bean.LimitConfiguration;
@RestController
public class LimitsConfigurationController {
	@GetMapping("/limits")
	public LimitConfiguration retriveLimitsFromConfigurations() {
		return new LimitConfiguration(1000, 1);
	}
}








package com.limitsService.bean;

public class LimitConfiguration {
	private int maximum;
	private int minimum;
//no-argument constructor  
	protected LimitConfiguration() {
	}
//generating getters  
	public int getMaximum() {
		return maximum;
	}
	public int getMinimum() {
		return minimum;
	}
//genetrating constructor using fields  
	public LimitConfiguration(int maximum, int minimum) {
		super();
		this.maximum = maximum;
		this.minimum = minimum;
	}
}




spring.application.name=limits-service
spring.cloud.config.enabled=false





spring.application.name=limits-service
#spring.cloud.config.enabled=false
spring.config.import=optional:configserver:










package com.limitsService.bean;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties("limitMinMax")
public class Configuration {
	private int maximum;
	private int minimum;

	public void setMaximum(int maximum) {
		this.maximum = maximum;
	}

	public void setMinimum(int minimum) {
		this.minimum = minimum;
	}

	public int getMaximum() {
		return maximum;
	}

	public int getMinimum() {
		return minimum;
	}
}










package com.limitsService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import com.limitsService.bean.*;

@RestController
public class LimitsConfigurationController {
	@Autowired
	private Configuration configuration;

	@GetMapping("/limits")
	public LimitConfiguration retriveLimitsFromConfigurations() {
//getting values from the properties file  
		return new LimitConfiguration(configuration.getMaximum(), configuration.getMinimum());
	}
}






spring.application.name=limits-service
limitMinMax.minimum=99  
limitMinMax.maximum=9999 
#spring.cloud.config.enabled=false
spring.config.import=optional:configserver:















