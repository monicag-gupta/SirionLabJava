To create a database:
use javadb
The db does not get created till we insert a collection into it

To create collection:
Directly by inserting documents:
	db.Employee.insert ({	"Employeeid" : 1,	"EmployeeName" : "Martin"	})
	
	db.Employee.insert (	{
			"Employeeid" : 2,
			"EmployeeName" : "Mart"
		}
	)


By Command:
db.createCollection(name, options) 
name is the db name
Options:
Capped:
Boolean
(Optional) If it is set to true, enables a capped collection. Capped collection is a fixed size collection that automatically overwrites its oldest entries when it reaches its maximum size. If you specify true, you need to specify size parameter also.
AutoIndexID:
Boolean
(Optional) If it is set to true, automatically create index on ID field. Its default value is false.
Size:
Number
(Optional) It specifies a maximum size in bytes for a capped collection. If capped is true, then you need to specify this field also.
Max:
Number
(Optional) It specifies the maximum number of documents allowed in the capped collection.



Insert a document:
db.myColl.insert({"name" : "seomount"})  




Data Types in MongoDB:
Integer: Integer type is used to store a numerical value. Depending upon your server. An integer can be 32 bit or 64 bit
String: String is the most commonly used datatype to store the data. In MongoDB ,the string must be UTF-8 valid
Boolean: Boolean type is used to store a boolean(true/ false) value
Double: Double is used to store floating point values
Min & Max key: The min/max keys are used to compare a value against the lowest and highest BSON elements
Array: Arrays type is used to store arrays or list or multiple values into one key
Timestamp: Timestamp can be handy for recording when a document has been modified or added
Object: Object is used for embedded documents
Null: Null type which is used to store a Null value
Date: Date is used to store the current date or time in UNIX time format
Symbol: Symbol is generally reserved for languages that use a specific symbol type, it is also used identically to a string
Object ID: The Object ID datatype is used to store the document’s ID
Binary Data: Binary data is used to store binary data
Code: Code is used to store JavaScript code into the document
Regular Expression: Regular Expression datatype is used to store regular expression



Read:
db.COLLECTION_NAME.find()


db.Employee.find()


db.Employee.find().forEach(printjson)

db.Employee.find().pretty()



db.Employee.insert ({	"Employeeid" : 1,	"EmployeeName" : "John Doe"	})
db.Employee.find({"Employeeid" : 1})




db.COLLECTION_NAME.update(SELECTION_CRITERIA, UPDATED_DATA)


db.Employee.update(
{"Employeeid" : 2},
{$set: { "EmployeeName" : "NewMartin"}});




Deleting Data

db.COLLECTION_NAME.remove(DELETION_CRITERIA)

db.Employee.insert ({	"Employeeid" : 22,	"EmployeeName" : "Jane Doe"	})

db.Employee.find()

db.Employee.remove({Employeeid:22})





In MongoDB, db.collection.drop() method is used to drop a collection from a database. It completely removes a collection from the database and does not leave any indexes associated with the dropped collections.
The db.collection.drop() method does not take any argument and produce an error when it is called with an argument. This method removes all the indexes associated with the dropped collection.
db.COLLECTION_NAME.drop()  
MongoDB Drop collection example
First check the already existing collections in your database.
>use EmployeeDB
> show collections  
Emp
Employee
>db.Emp.drop()  
True
Now check the collections in the database:
>show collections  
Employee
Now, there are no existing collections in your database.
Note: The drop command returns true if it successfully drops a collection. It returns false when there is no existing collection to drop.





use Testdb
db.movie.insert({"name":"Justice League"})
MongoDB db.dropDatabase() command is used to drop a existing database.
Basic syntax of dropDatabase() command is as follows −
db.dropDatabase()
This will delete the selected database. If you have not selected any database, then it will delete default 'test' database.
check the list of available databases by using the command, show dbs.
show dbs
Check current db:
db
Testdb
use javadb









Operation
Syntax
Example
RDBMS Equivalent
Equality
{<key>:{$eg;<value>}}
db.Employee.find({"EmployeeName":"Joe"}).pretty()
where EmployeeName = 'Joe'
Less Than
{<key>:{$lt:<value>}}
db.Employee.find({"Employeeid":{$lt:5}}).pretty()
where Employeeid < 5
Less Than Equals
{<key>:{$lte:<value>}}
db.Employee.find({"Employeeid":{$lte:5}}).pretty()
where Employeeid <= 5
Greater Than
{<key>:{$gt:<value>}}
db.Employee.find({"Employeeid":{$gt:5}}).pretty()
where Employeeid > 5
Greater Than Equals
{<key>:{$gte:<value>}}
db.Employee.find({"Employeeid":{$gte:5}}).pretty()
where Employeeid >= 5
Not Equals
{<key>:{$ne:<value>}}
db.Employee.find({"Employeeid":{$ne:5}}).pretty()
where Employeeid != 5
Values in an array
{<key>:{$in:[<value1>, <value2>,……<valueN>]}}
db.Employee.find({“EmployeeName":{$in:["Raj", "Ram", "Raghu"]}}).pretty()
Where EmployeeName matches any of the value in :["Raj", "Ram", "Raghu"]
Values not in an array
{<key>:{$nin:<value>}}
db.Employee.find({“EmployeeName":{$nin:["Raj", "Ram", "Raghu"]}}).pretty()
Where EmployeeName values is not in the array :["Ramu", "Raghav"] or, doesn’t exist at all








SQL SELECT Statement
MongoDB find() Statement
SELECT * FROM Employee
db.Employee.find()
SELECT id, Employeeid, EmployeeName FROM Employee
db.Employee.find( { }, { Employeeid: 1, EmployeeName: 1 } )
SELECT Employeeid, EmployeeName FROM Employee
db.Employee.find( { }, { Employeeid: 1, EmployeeName: 1, _id: 0 } )
SELECT * FROM Employee WHERE EmployeeName = "B"
db.Employee.find( { EmployeeName: "A" } )
SELECT Employeeid, EmployeeName FROM Employee WHERE EmployeeName = "A"
db.Employee.find( { EmployeeName: "A" }, { Employeeid: 1, EmployeeName: 1, _id: 0 } )
SELECT * FROM Employee WHERE EmployeeName != "A"
db.Employee.find( { EmployeeName: { $ne: "A" } } )
SELECT * FROM Employee WHERE EmployeeName = "A" AND Employeeid = 50
db.Employee.find( { EmployeeName: "A", Employeeid: 50 } )
SELECT * FROM Employee WHERE EmployeeName = "A" OR Employeeid = 50
db.Employee.find( { $or: [ { EmployeeName: "A" } , { Employeeid: 50 } ] } )
SELECT * FROM Employee WHERE Employeeid > 25
db.Employee.find( { Employeeid: { $gt: 25 } } )
SELECT * FROM Employee WHERE Employeeid < 25
Db.Employee.find( { Employeeid: { $lt: 25 } } )
SELECT * FROM Employee WHERE Employeeid > 25 AND Employeeid <= 50
db.Employee.find( { Employeeid: { $gt: 25, $lte: 50 } } )
SELECT * FROM Employee WHERE Employeeid like "%bc%"
db.Employee.find( { Employeeid: /bc/ } ) -or- db.Employee.find( { Employeeid: { $regex: /bc/ } } )
SELECT * FROM Employee WHERE Employeeid like "bc%"
db.Employee.find( { Employeeid: /^bc/ } ) -or- db.Employee.find( { Employeeid: { $regex: /^bc/ } } )
SELECT * FROM Employee WHERE EmployeeName = "A" ORDER BY Employeeid ASC
db. Employee. find( { EmployeeName: "A" } ). sort( { Employeeid: 1 } )
SELECT * FROM Employee WHERE EmployeeName = "A" ORDER BY Employeeid ASC
db. Employee. find( { EmployeeName: "A" } ). sort( { Employeeid: 1 } )
SELECT * FROM Employee WHERE EmployeeName = "A" ORDER BY Employeeid ASC
db. Employee. find( { EmployeeName: "A" } ). sort( { Employeeid: 1 } )
SELECT * FROM Employee WHERE EmployeeName = "A" ORDER BY Employeeid DESC
db. Employee. find( { EmployeeName: "A" } ). sort( { Employeeid: -1 } )
SELECT * FROM Employee WHERE EmployeeName = "A" ORDER BY Employeeid DESC
db. Employee. find( { EmployeeName: "A" } ). sort( { Employeeid: -1 } )
SELECT COUNT(*) FROM Employee
db. Employee. count() or db. Employee. find(). count()
SELECT COUNT(Employeeid) FROM Employee 
db. Employee.count( { Employeeid: { $exists: true } } ) or db. Employee.find( { Employeeid: { $exists: true } } ).count()
SELECT COUNT(*) FROM Employee WHERE Employeeid > 30
db. Employee.count( { Employeeid: { $gt: 30 } } ) or db. Employee.find( { Employeeid: { $gt: 30 } } ).count()
SELECT DISTINCT(EmployeeName) FROM Employee
db. Employee.aggregate( [ { $group : { _id : "$EmployeeName" } } ] ) or, for distinct value sets that do not exceed the BSON size limit db. Employee.distinct( "EmployeeName" )
SELECT * FROM Employee LIMIT 1
db. Employee.findOne() or db. Employee.find(). limit(1)
SELECT * FROM Employee LIMIT 5 SKIP 10
db. Employee.find(). limit(5). skip(10)
EXPLAIN SELECT * FROM Employee WHERE EmployeeName = "A"
db. Employee. find( { EmployeeName: "A" } ). explain()




db.collection.createIndex() 


db.Employee.createIndex ( { Employeeid: 1 } )
db.Employee.getIndexes()

db.collection.dropIndex(index)

db.Employee.dropIndex("index for Emp" );
{ nIndexesWas: 2, ok: 1 }
db.Employee.dropIndex("Employeeid_1" );
or 
db.Employee.dropIndex( { "Employeeid": 1 } );



Aggregation expressions use EmployeeDB

Expression
Description
Example
$sum
Sums up the defined value from all documents in the collection.
db.Employee.aggregate([{$group : {_id : "$EmployeeName", sum_empid : {$sum : "$Employeeid"}}}])
$avg
Calculates the average of all given values from all documents in the collection.
db.Employee.aggregate([{$group : {_id : "$EmployeeName", avg_empid : {$avg : "$Employeeid"}}}])
$min
Gets the minimum of the corresponding values from all documents in the collection.
db.Employee.aggregate([{$group : {_id : "$EmployeeName", min_empid : {$min : "$Employeeid"}}}])
$max
Gets the maximum of the corresponding values from all documents in the collection.
db.Employee.aggregate([{$group : {_id : "$EmployeeName", max_empid : {$max : "$Employeeid"}}}])
$first
Gets the first document from the source documents according to the grouping. Typically this makes only sense together with some previously applied “$sort”-stage.
db.Employee.aggregate([{$group : {_id : "$EmployeeName", first_empid : {$first : "$Employeeid"}}}])
$last
Gets the last document from the source documents according to the grouping. Typically this makes only sense together with some previously applied “$sort”-stage.
db.Employee.aggregate([{$group : {_id : "$EmployeeName", last_empid : {$last : "$Employeeid"}}}])





















